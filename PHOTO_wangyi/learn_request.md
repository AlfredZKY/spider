# requests模块的iter_content方法  
这里我用python的request模块作为例子，需要获取文本的时候，会使用response.text获取文本信息，使用response.content获取字节流，比如下载图片保存到一个文件，而对于大个的文件我们采用分块读取的方式了。  

# requests.get方法的stream
第一步,需要设置request.get的stream参数为True。  
默认情况下是stream的值为false，它会立即开始下载文件并存放到内存当中，倘若文件过大就会导致内存不足的情况，
当把get函数的steam参数设置为True时，它不会立即开始下载，当你使用iter_content或iter_lines遍历内容或者访问内容属性时才开始下载。需要注意一点，文件没有下载前，它也需要保持连接。  
- iter_content:一块一块的遍历要下载的内容  
- iter_lines:一行一行的遍历要下载的内容  
使用上面两个函数下载大文件可以防止占用过多的内存，因为每次只下载小部分数据。  

# 断点续传
所谓断点续传，也就是要从文件已经下载的地方开始继续下载。在以前版本的HTTP协议是不支持断点的HTTP/1.1开始就支持了。一般断点下载时会用到header请求头的Range字段，也就是现在众多号称多线程下载工具实现多线程下载的核心所在。  

# HTTP请求头Range
range是请求资源的部分内容(不包括响应头的大小)，单位是byte，即字节，从0开始。如果服务器能够正常响应的话，服务器会返回206 Partial Content的状态码说明，如果不能处理这种Range的话，就会返回整个资源以及响应状态码为200 OK.(这个要注意，要分段下载时，要先判断这个)  

# Range请求头格式
Range：bytes=start-end  

# Range头域  
Range头域可以请求实体的一个或者多个子范围。例如:
表示头500个字节：bytes=0-499
表示第二个500个字节：bytes=500-999
表示最后500个字节:bytes=-500
表示500字节以后的范围:bytes=500-
第一个和最后一个字节:bytes=0-0,-1
同时指定几个范围:bytes=500-600,601-999
例：
Range：bytes=10- :第10个字节及最后个字节的数据
Range：bytes=40-100：第40个字节到第100个字节之间的数据
注意，这个表示[start,end],既是包含请求头的start及end字节的，所以，下一个请求，应该是上一个请求的[end+1,nextEnd]